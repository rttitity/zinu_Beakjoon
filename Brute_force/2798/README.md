# [백준 - 브론즈 2] 블랙잭 (2798번)

## ⏰  **time**

60분

## :pushpin: **Algorithm**

브루트포스 알고리즘

## ⏲️**Time Complexity**

$O(1)$

## :round_pushpin: **Logic**

1. 카드의 장수값 n과 최댓값 m을 입력받고, 다음 한 줄에 카드에 쓰여있는 수를 입력받습니다.
2. 주어진 카드 장수중 3장의 카드를 골라 m값을 넘지 않으면서 최대한 가까운 값을 구해야 합니다. 따라서 이 문제풀이는 모든 카드의 경우의 수를 구해볼 필요가 있습니다.
3. 반복문을 활용하여 첫번째 카드를 고를 i반복문, 두번째 카드를 고를 j반복문, 세번째 카드를 고를 k반복문을 작성합니다.
4. j반복문(두번째카드)은 i가 고른 카드를 제외하고 그 다음카드부터(i+1) n까지 그리고 k반복문(3번째카드)은 j반복문의 다음(j+1)부터 N까지 반복문을 돌려 모든 카드의 경우의 수를 파악합니다.
5. 마지막 k 반복문에서 조건문을 걸어 이번 반복회차 조건이 ,m보다 작거나 같으면 result 변수에 리스트로 하나씩 저장합니다.
6. 모든 반복문이 종료되면 result값에서 최댓값을 구한다면 그것이 가장 근접한 3가지의 카드 합 입니다.

## :black_nib: **Review**

- 난이도가 올라가니까 첫 문제부터 머리를 싸메게 되었다.
- 문제를 읽고 생각해본 결과 모든 경우의 수를 비교하는것만이 방법일거 같아 for문 3개를 써서 카드의 경우를 비교해봐야겠다고 생각했다.
- 처음에 모든 경우의 합을 구하기 위해 풀이를 했으나 런타임 오류가 났다.

## 첫 문제풀이 오류
```
import sys
n, m = map(int, sys.stdin.readline().split())
Nlist = list(map(int, sys.stdin.readline().split()))
result =[]
x = []

for i in range(n):
    for j in range(n):
       for k in range(n):
           if i != j and j != k and i != k:
                if (Nlist[i] + Nlist[j] + Nlist[k]) <= m :
                    result.append(Nlist[i] + Nlist[j] + Nlist[k])

print(max(result1))
```
- 위 보기처럼 문제풀이를 진행하였다. 출력은 문제풀이대로 잘 나왔다. (많이 헤메서 시행착오가 매우 많았다...)
- 모든 카드의 경우의 수를 확인하기 위해 for문 3개를 동일하게 사용했고 중복되는 카드선택을 막기 위해 k반북문(3번째 카드)에 조건문을 걸어 i, j, k값이 서로 다를때 result값에 넣도록 풀이하였다.
- 하지만 문제점은 값은 들어가지 않을지 몰라도 for문은 그대로 돌아서 런타임이 길어진다는 점이다.
- 그래서 중복되는 카드의 경우 for문에서도 계산하지 않게 하도록 풀이방법을 생각해야만 했다.
- 사고가 잘 되지 않아 노트에 직접 경우를 적어가다보니 앞쪽 for문에서 계산한 경우를 하나씩 제외하는 방법이 생각났다.
- 안쪽 for문의 시작을 바깥쪽 for문의 초기값에 +1를 하는 방법이었다.
- 다 풀고나니 정말 허무하다.. 아직 갈 길이 많이 멀구나..

