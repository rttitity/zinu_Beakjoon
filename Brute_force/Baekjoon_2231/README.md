# [백준 - 브론즈 2] 분해합 (2231번)

## ⏰  **time**

60분 이상

## :pushpin: **Algorithm**

브루트포스 알고리즘

## ⏲️**Time Complexity**

$O(1)$

## :round_pushpin: **Logic**

1. 분해합은 생성자와 각 자릿수를 모두 더한 숫자이므로 N에 N자리수당 9를 곱한수를 뺀 수(N - (N의자리수*9)) 부터 N 사이에서 나올수 밖에 없다.
2. 계산 시간을 줄이기 위해 입력받은 값의 자리수 부터 알아보고 시작범위 V를 찾아준다.
3. 반복문 while을 통해 number에 N값을 넣어 number가 1 이상일때 나눠주고 N_number(입력값의 자리수)를 1씩 더해준다. 이러면 반복문이 끝났을때 N값의 자리수를 알게된다.
4. N_number(자리수)에 9를 곱해 N값에서 빼주고 범위 시작값 V에 넣어준다.
5. 반복문 for문을 통해 V부터 N까지의 범위중에서 분해합을 찾는다. 입력값이 2자리수일때는 18보다 작은값을 입력받을 경우 V값이 1보다 작아져 시작값이 음수가 되어버리므로 N이 18미만일경우 v값을 0으로 변환해주는 조건문을 걸어주었다.
6. V값부터 i를 통해 찾아주며 i를 str()를 통해 문자열로 나눠준 후 map() 과 sum()함수를 통해 각 자릿수값을 더해주어 num값에 넣는다.
7. 그리고 i와 num을 더하여 분해합을 찾는 총합 num_sum에 넣어준다.
8. num_sum이 i와 동일할때 분해합의 최솟값을 찾은 경우 이므로 그때의 i값을 출력해주고 반복문을 break로 종료시킨다.
9. 만일 i가 N-1값일 경우 분해합이 나올 수 있는 범위중 찾지 못한것이므로 분해합이 없는 수를 입력받은것이다. 따라서 0을 출력해주어 프로그램을 종료시킨다.

## :black_nib: **Review**

- 풀이시간이 초과되어 힌트를 찾아 문제풀이를 진행하였다.
- 분해합은 어떤 자연수 N을 N과 각자릿수를 1의 자리로 하여 합산한 수인데 처음에 전체 범위를 찾아야겠다고 생각했지만 7자리수 이상의 수를 다 뒤지기엔 효율적인 프로그램이 되지 못할거같다는 생각을 했고 계속 생각해본 결과 분해합의 범위를 생각할 수 있었다.

